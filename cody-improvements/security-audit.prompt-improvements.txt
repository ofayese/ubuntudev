After analyzing the `.github/prompts/security-audit.prompt.md` file, I've identified several areas for improvement that would enhance its effectiveness as a comprehensive security auditing framework:

## **1. Missing Dynamic Security Analysis and Runtime Vulnerability Detection**

**Issue**: The prompt focuses primarily on static code analysis patterns but lacks guidance for dynamic security testing, runtime vulnerability detection, and behavioral analysis of shell scripts during execution.

**Benefits**: Dynamic analysis can detect security vulnerabilities that only manifest during runtime, such as race conditions, memory corruption issues, privilege escalation attempts, and environment-specific security flaws that static analysis might miss.

**Recommendation**:
```bash
# Dynamic Security Analysis Framework
setup_dynamic_security_monitoring() {
  local script_path="$1"
  local monitoring_session="security_audit_$(date +%s)"
  
  # Enable comprehensive security monitoring
  export SECURITY_AUDIT_SESSION="$monitoring_session"
  export ENABLE_SYSCALL_MONITORING=true
  export ENABLE_NETWORK_MONITORING=true
  export ENABLE_FILE_ACCESS_MONITORING=true
  
  # Setup security event logging
  local security_log="/tmp/security_audit_${monitoring_session}.log"
  exec 3> >(tee -a "$security_log")
  
  # Monitor system calls for security violations
  if command_exists strace; then
    strace -f -e trace=file,network,process -o "${security_log}.strace" \
      bash "$script_path" 2>&3 &
    local strace_pid=$!
  fi
  
  # Monitor file system access patterns
  if command_exists inotifywait; then
    inotifywait -m -r -e create,delete,modify,attrib /tmp /var /etc \
      --format '%T %w%f %e' --timefmt '%Y-%m-%d %H:%M:%S' \
      >> "${security_log}.fsmon" 2>/dev/null &
    local inotify_pid=$!
  fi
  
  # Return monitoring PIDs for cleanup
  echo "$strace_pid:$inotify_pid:$security_log"
}

analyze_runtime_security_behavior() {
  local monitoring_data="$1"
  IFS=':' read -r strace_pid inotify_pid security_log <<< "$monitoring_data"
  
  # Analyze system call patterns for security violations
  if [ -f "${security_log}.strace" ]; then
    # Check for suspicious system calls
    local suspicious_calls=(
      "execve.*sh.*-c"     # Command injection patterns
      "open.*\.\./.*O_RDWR" # Path traversal attempts
      "socket.*AF_INET"    # Unexpected network connections
      "setuid\|setgid"     # Privilege escalation attempts
    )
    
    for pattern in "${suspicious_calls[@]}"; do
      if grep -E "$pattern" "${security_log}.strace" >/dev/null 2>&1; then
        echo "SECURITY VIOLATION: Suspicious system call pattern detected: $pattern"
      fi
    done
  fi
  
  # Analyze file system access patterns
  if [ -f "${security_log}.fsmon" ]; then
    # Check for unauthorized file access
    while IFS= read -r line; do
      if [[ "$line" =~ /etc/passwd|/etc/shadow|/root/ ]]; then
        echo "SECURITY VIOLATION: Unauthorized access to sensitive file: $line"
      fi
    done < "${security_log}.fsmon"
  fi
}
```

## **2. Lack of Automated Security Policy Enforcement and Compliance Checking**

**Issue**: The prompt provides manual security checklists but doesn't include automated policy enforcement mechanisms or compliance framework integration (CIS benchmarks, NIST guidelines, etc.).

**Benefits**: Automated policy enforcement ensures consistent security standards, reduces human error in security audits, and provides compliance reporting for regulatory requirements.

**Recommendation**:
```bash
# Security Policy Enforcement Framework
enforce_security_policies() {
  local script_path="$1"
  local policy_level="${2:-standard}" # standard, strict, compliance
  
  # Load security policies based on level
  case "$policy_level" in
    "strict")
      load_strict_security_policies
      ;;
    "compliance")
      load_compliance_security_policies
      ;;
    *)
      load_standard_security_policies
      ;;
  esac
  
  # Automated security policy checks
  check_script_permissions "$script_path"
  check_hardcoded_credentials "$script_path"
  check_input_validation_patterns "$script_path"
  check_privilege_requirements "$script_path"
  check_network_security_patterns "$script_path"
  
  # Generate compliance report
  generate_compliance_report "$script_path" "$policy_level"
}

check_cis_benchmark_compliance() {
  local script_path="$1"
  local cis_violations=()
  
  # CIS Benchmark 5.1.1: Ensure cron daemon is enabled
  if grep -q "crontab\|cron" "$script_path"; then
    if ! systemctl is-enabled cron >/dev/null 2>&1; then
      cis_violations+=("CIS-5.1.1: Cron daemon not properly configured")
    fi
  fi
  
  # CIS Benchmark 5.2.1: Ensure permissions on /etc/ssh/sshd_config are configured
  if grep -q "ssh\|sshd_config" "$script_path"; then
    if [ -f /etc/ssh/sshd_config ]; then
      local perms
      perms=$(stat -c "%a" /etc/ssh/sshd_config)
      if [ "$perms" != "600" ]; then
        cis_violations+=("CIS-5.2.1: SSH config permissions not secure: $perms")
      fi
    fi
  fi
  
  # CIS Benchmark 6.1.10: Ensure no world writable files exist
  if grep -q "chmod.*777\|chmod.*o+w" "$script_path"; then
    cis_violations+=("CIS-6.1.10: Script creates world-writable files")
  fi
  
  # Report violations
  if [ ${#cis_violations[@]} -gt 0 ]; then
    echo "CIS Benchmark Violations Detected:"
    printf '%s\n' "${cis_violations[@]}"
    return 1
  fi
  
  return 0
}

generate_security_policy_report() {
  local script_path="$1"
  local policy_level="$2"
  local report_file="security_policy_report_$(date +%Y%m%d_%H%M%S).json"
  
  cat > "$report_file" << EOF
{
  "audit_timestamp": "$(date -Iseconds)",
  "script_path": "$script_path",
  "policy_level": "$policy_level",
  "compliance_frameworks": {
    "cis_benchmark": $(check_cis_benchmark_compliance "$script_path" >/dev/null 2>&1 && echo true || echo false),
    "nist_cybersecurity": $(check_nist_compliance "$script_path" >/dev/null 2>&1 && echo true || echo false),
    "owasp_guidelines": $(check_owasp_compliance "$script_path" >/dev/null 2>&1 && echo true || echo false)
  },
  "policy_violations": $(get_policy_violations "$script_path" | jq -R . | jq -s .),
  "security_score": $(calculate_security_score "$script_path"),
  "recommendations": $(generate_security_recommendations "$script_path" | jq -R . | jq -s .)
}
EOF
  
  echo "$report_file"
}
```

## **3. Insufficient Coverage of Supply Chain Security and Dependency Vulnerabilities**

**Issue**: The prompt doesn't address supply chain security concerns, such as validating external downloads, checking package integrity, or scanning for vulnerable dependencies in shell scripts.

**Benefits**: Supply chain attacks are increasingly common. Comprehensive dependency security scanning helps prevent malicious code injection through compromised external resources and ensures the integrity of downloaded components.

**Recommendation**:
```bash
# Supply Chain Security Analysis
analyze_supply_chain_security() {
  local script_path="$1"
  local supply_chain_report="supply_chain_analysis_$(date +%s).json"
  
  # Extract all external dependencies
  local external_urls=()
  local package_installs=()
  local binary_downloads=()
  
  # Find URLs in script
  while IFS= read -r line; do
    if [[ "$line" =~ https?://[^[:space:]]+ ]]; then
      external_urls+=("${BASH_REMATCH[0]}")
    fi
  done < "$script_path"
  
  # Find package installations
  while IFS= read -r line; do
    if [[ "$line" =~ (apt|yum|dnf|pacman|snap)\ install\ ([^;]+) ]]; then
      package_installs+=("${BASH_REMATCH[2]}")
    fi
  done < "$script_path"
  
  # Validate external URLs
  validate_external_dependencies "${external_urls[@]}"
  
  # Check package signatures and integrity
  verify_package_integrity "${package_installs[@]}"
  
  # Scan for known vulnerabilities
  scan_dependency_vulnerabilities "${package_installs[@]}"
  
  # Generate supply chain security report
  generate_supply_chain_report "$supply_chain_report" \
    "${external_urls[@]}" "${package_installs[@]}"
}

validate_external_dependencies() {
  local urls=("$@")
  local validation_results=()
  
  for url in "${urls[@]}"; do
    # Check URL reputation
    local url_reputation
    url_reputation=$(check_url_reputation "$url")
    
    # Validate SSL certificate
    local ssl_valid=false
    if [[ "$url" =~ ^https:// ]]; then
      if curl -s --head "$url" >/dev/null 2>&1; then
        ssl_valid=true
      fi
    fi
    
    # Check for known malicious domains
    local domain
    domain=$(echo "$url" | sed -E 's|https?://([^/]+).*|\1|')
    if check_malicious_domain_list "$domain"; then
      validation_results+=("CRITICAL: Malicious domain detected: $domain")
    fi
    
    # Validate content integrity if checksums are provided
    if grep -q "sha256\|md5sum" <<< "$url"; then
      validate_download_integrity "$url"
    else
      validation_results+=("WARNING: No integrity validation for: $url")
    fi
  done
  
  # Report validation results
  if [ ${#validation_results[@]} -gt 0 ]; then
    echo "Supply Chain Validation Issues:"
    printf '%s\n' "${validation_results[@]}"
  fi
}

scan_dependency_vulnerabilities() {
  local packages=("$@")
  local vulnerability_db="/tmp/vulnerability_db.json"
  
  # Download latest vulnerability database
  if command_exists curl; then
    curl -s "https://api.osv.dev/v1/query" \
      -H "Content-Type: application/json" \
      -d '{"package": {"ecosystem": "Debian", "name": "'"${packages[0]}"'"}}' \
      > "$vulnerability_db" 2>/dev/null || true
  fi
  
  # Check each package for known vulnerabilities
  for package in "${packages[@]}"; do
    # Query vulnerability database
    local vulnerabilities
    vulnerabilities=$(jq -r '.vulns[]? | select(.affected[]?.package.name == "'"$package"'") | .id' \
      "$vulnerability_db" 2>/dev/null || echo "")
    
    if [ -n "$vulnerabilities" ]; then
      echo "VULNERABILITY: Package $package has known vulnerabilities:"
      echo "$vulnerabilities" | while read -r vuln_id; do
        echo "  - $vuln_id"
      done
    fi
  done
  
  rm -f "$vulnerability_db"
}
```

## **4. Missing Advanced Threat Detection and Behavioral Analysis**

**Issue**: The prompt lacks sophisticated threat detection mechanisms that can identify advanced attack patterns, anomalous behavior, or sophisticated evasion techniques commonly used in modern attacks.

**Benefits**: Advanced threat detection helps identify sophisticated attacks that bypass traditional security measures, including zero-day exploits, advanced persistent threats (APTs), and polymorphic malware that might be embedded in shell scripts.

**Recommendation**:
```bash
# Advanced Threat Detection Framework
setup_advanced_threat_detection() {
  local script_path="$1"
  local threat_detection_config="/tmp/threat_detection_$(date +%s).conf"
  
  # Initialize threat detection patterns
  cat > "$threat_detection_config" << 'EOF'
# Advanced threat patterns
OBFUSCATION_PATTERNS=(
  'eval.*\$\(.*base64'
  'echo.*|.*base64.*-d'
  '\$\{[^}]*//[^}]*\}'
  'tr.*[a-zA-Z].*[a-zA-Z]'
)

EVASION_TECHNIQUES=(
  'sleep.*[0-9]+.*&&'
  'timeout.*[0-9]+.*'
  'nohup.*&.*disown'
  '/dev/tcp/.*/'
)

PERSISTENCE_MECHANISMS=(
  'crontab.*-e'
  '\.bashrc.*echo'
  '\.profile.*export'
  'systemctl.*enable'
)

DATA_EXFILTRATION_PATTERNS=(
  'curl.*-X.*POST.*-d'
  'wget.*--post-data'
  'nc.*-l.*-p.*[0-9]+'
  'ssh.*-R.*[0-9]+:'
)
EOF
  
  source "$threat_detection_config"
  
  # Analyze script for advanced threats
  detect_code_obfuscation "$script_path"
  detect_evasion_techniques "$script_path"
  detect_persistence_mechanisms "$script_path"
  detect_data_exfiltration "$script_path"
  detect_anomalous_behavior "$script_path"
  
  rm -f "$threat_detection_config"
}

detect_code_obfuscation() {
  local script_path="$1"
  local obfuscation_score=0
  local obfuscation_indicators=()
  
  # Check for base64 encoding patterns
  if grep -E 'base64.*-d|decode' "$script_path" >/dev/null 2>&1; then
    ((obfuscation_score += 25))
    obfuscation_indicators+=("Base64 decoding detected")
  fi
  
  # Check for variable substitution obfuscation
  local var_substitutions
  var_substitutions=$(grep -c '\${[^}]*//[^}]*}' "$script_path" 2>/dev/null || echo 0)
  if [ "$var_substitutions" -gt 5 ]; then
    ((obfuscation_score += 20))
    obfuscation_indicators+=("Excessive variable substitution: $var_substitutions instances")
  fi
  
  # Check for character translation obfuscation
  if grep -E 'tr.*[a-zA-Z].*[a-zA-Z]' "$script_path" >/dev/null 2>&1; then
    ((obfuscation_score += 15))
    obfuscation_indicators+=("Character translation obfuscation detected")
  fi
  
  # Check for eval with dynamic content
  if grep -E 'eval.*\$\(' "$script_path" >/dev/null 2>&1; then
    ((obfuscation_score += 30))
    obfuscation_indicators+=("Dynamic eval execution detected")
  fi
```
```bash
  # Check for hexadecimal encoding
  local hex_patterns
  hex_patterns=$(grep -c '\\x[0-9a-fA-F][0-9a-fA-F]' "$script_path" 2>/dev/null || echo 0)
  if [ "$hex_patterns" -gt 10 ]; then
    ((obfuscation_score += 20))
    obfuscation_indicators+=("Hexadecimal encoding detected: $hex_patterns instances")
  fi
  
  # Report obfuscation analysis
  if [ "$obfuscation_score" -gt 50 ]; then
    echo "CRITICAL THREAT: High obfuscation score detected: $obfuscation_score/100"
    printf '%s\n' "${obfuscation_indicators[@]}" | sed 's/^/  - /'
  elif [ "$obfuscation_score" -gt 25 ]; then
    echo "WARNING: Moderate obfuscation detected: $obfuscation_score/100"
    printf '%s\n' "${obfuscation_indicators[@]}" | sed 's/^/  - /'
  fi
}

detect_anomalous_behavior() {
  local script_path="$1"
  local anomaly_score=0
  local anomalies=()
  
  # Analyze script complexity and entropy
  local line_count
  line_count=$(wc -l < "$script_path")
  local unique_commands
  unique_commands=$(grep -oE '^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*' "$script_path" | sort -u | wc -l)
  
  # Calculate command diversity ratio
  local diversity_ratio
  diversity_ratio=$(echo "scale=2; $unique_commands / $line_count" | bc -l 2>/dev/null || echo 0)
  
  # High diversity might indicate obfuscation or malicious activity
  if (( $(echo "$diversity_ratio > 0.8" | bc -l 2>/dev/null || echo 0) )); then
    ((anomaly_score += 20))
    anomalies+=("Unusually high command diversity: $diversity_ratio")
  fi
  
  # Check for unusual network activity patterns
  local network_commands
  network_commands=$(grep -cE 'curl|wget|nc|telnet|ssh|scp|rsync' "$script_path" 2>/dev/null || echo 0)
  if [ "$network_commands" -gt 10 ]; then
    ((anomaly_score += 25))
    anomalies+=("Excessive network commands: $network_commands")
  fi
  
  # Check for file system manipulation patterns
  local fs_commands
  fs_commands=$(grep -cE 'rm|mv|cp|chmod|chown|find.*-exec' "$script_path" 2>/dev/null || echo 0)
  if [ "$fs_commands" -gt 20 ]; then
    ((anomaly_score += 20))
    anomalies+=("Excessive file system manipulation: $fs_commands commands")
  fi
  
  # Check for process manipulation
  local process_commands
  process_commands=$(grep -cE 'kill|killall|pkill|nohup|disown|jobs' "$script_path" 2>/dev/null || echo 0)
  if [ "$process_commands" -gt 5 ]; then
    ((anomaly_score += 15))
    anomalies+=("Process manipulation detected: $process_commands commands")
  fi
  
  # Report anomaly analysis
  if [ "$anomaly_score" -gt 40 ]; then
    echo "THREAT DETECTED: Anomalous behavior score: $anomaly_score/100"
    printf '%s\n' "${anomalies[@]}" | sed 's/^/  - /'
  fi
}

# Machine learning-inspired threat scoring
calculate_threat_score() {
  local script_path="$1"
  local weights_config="/tmp/threat_weights.conf"
  
  # Define threat scoring weights
  cat > "$weights_config" << 'EOF'
OBFUSCATION_WEIGHT=0.3
EVASION_WEIGHT=0.25
PERSISTENCE_WEIGHT=0.2
EXFILTRATION_WEIGHT=0.15
ANOMALY_WEIGHT=0.1
EOF
  
  source "$weights_config"
  
  # Calculate individual threat scores
  local obfuscation_score
  obfuscation_score=$(detect_code_obfuscation "$script_path" 2>/dev/null | grep -oE '[0-9]+/100' | cut -d'/' -f1 || echo 0)
  
  local evasion_score
  evasion_score=$(detect_evasion_techniques "$script_path" 2>/dev/null | grep -oE '[0-9]+/100' | cut -d'/' -f1 || echo 0)
  
  local persistence_score
  persistence_score=$(detect_persistence_mechanisms "$script_path" 2>/dev/null | grep -oE '[0-9]+/100' | cut -d'/' -f1 || echo 0)
  
  local exfiltration_score
  exfiltration_score=$(detect_data_exfiltration "$script_path" 2>/dev/null | grep -oE '[0-9]+/100' | cut -d'/' -f1 || echo 0)
  
  local anomaly_score
  anomaly_score=$(detect_anomalous_behavior "$script_path" 2>/dev/null | grep -oE '[0-9]+/100' | cut -d'/' -f1 || echo 0)
  
  # Calculate weighted threat score
  local total_threat_score
  total_threat_score=$(echo "scale=2; \
    ($obfuscation_score * $OBFUSCATION_WEIGHT) + \
    ($evasion_score * $EVASION_WEIGHT) + \
    ($persistence_score * $PERSISTENCE_WEIGHT) + \
    ($exfiltration_score * $EXFILTRATION_WEIGHT) + \
    ($anomaly_score * $ANOMALY_WEIGHT)" | bc -l)
  
  rm -f "$weights_config"
  echo "$total_threat_score"
}
```

## **5. Absence of Automated Remediation and Security Hardening Suggestions**

**Issue**: The prompt identifies security issues but doesn't provide automated remediation capabilities or specific hardening recommendations that can be immediately implemented.

**Benefits**: Automated remediation reduces the time between vulnerability discovery and resolution, ensures consistent security fixes, and provides actionable guidance for developers to improve script security.

**Recommendation**:
```bash
# Automated Security Remediation Framework
generate_security_remediation_plan() {
  local script_path="$1"
  local remediation_plan="/tmp/security_remediation_$(date +%s).json"
  local auto_fix="${2:-false}"
  
  # Analyze security issues and generate remediation steps
  local security_issues
  security_issues=$(perform_comprehensive_security_audit "$script_path")
  
  # Generate structured remediation plan
  cat > "$remediation_plan" << EOF
{
  "script_path": "$script_path",
  "audit_timestamp": "$(date -Iseconds)",
  "remediation_plan": {
    "critical_fixes": [],
    "security_improvements": [],
    "hardening_recommendations": [],
    "automated_fixes": []
  }
}
EOF
  
  # Process each security issue and generate remediation
  while IFS= read -r issue; do
    generate_remediation_for_issue "$issue" "$remediation_plan" "$auto_fix"
  done <<< "$security_issues"
  
  # Apply automated fixes if requested
  if [ "$auto_fix" = "true" ]; then
    apply_automated_security_fixes "$script_path" "$remediation_plan"
  fi
  
  echo "$remediation_plan"
}

generate_remediation_for_issue() {
  local issue="$1"
  local remediation_plan="$2"
  local auto_fix="$3"
  
  case "$issue" in
    *"unquoted variable"*)
      local fix_command="sed -i 's/\$\([a-zA-Z_][a-zA-Z0-9_]*\)/\"\$\1\"/g' $script_path"
      add_remediation_step "$remediation_plan" "critical_fixes" \
        "Quote all variable expansions" "$fix_command" "true"
      ;;
    
    *"hardcoded credential"*)
      add_remediation_step "$remediation_plan" "critical_fixes" \
        "Remove hardcoded credentials and use environment variables" \
        "# Manual review required - replace hardcoded values with \${ENV_VAR}" "false"
      ;;
    
    *"command injection"*)
      add_remediation_step "$remediation_plan" "critical_fixes" \
        "Sanitize input and use array-based command execution" \
        "# Replace: cmd=\"\$input\"; \$cmd with: cmd_array=(\$input); \"\${cmd_array[@]}\"" "false"
      ;;
    
    *"insecure temporary file"*)
      local fix_command="sed -i 's|/tmp/[^[:space:]]*|$(mktemp)|g' $script_path"
      add_remediation_step "$remediation_plan" "security_improvements" \
        "Use mktemp for secure temporary file creation" "$fix_command" "true"
      ;;
    
    *"missing input validation"*)
      add_remediation_step "$remediation_plan" "security_improvements" \
        "Add input validation functions" \
        "$(generate_input_validation_template)" "true"
      ;;
  esac
}

add_remediation_step() {
  local remediation_plan="$1"
  local category="$2"
  local description="$3"
  local fix_command="$4"
  local automated="$5"
  
  local remediation_step
  remediation_step=$(cat << EOF
{
  "description": "$description",
  "fix_command": "$fix_command",
  "automated": $automated,
  "priority": "$(determine_priority "$description")",
  "estimated_effort": "$(estimate_effort "$description")"
}
EOF
)
  
  # Add to remediation plan
  local updated_plan
  updated_plan=$(jq ".remediation_plan.$category += [$remediation_step]" "$remediation_plan")
  echo "$updated_plan" > "$remediation_plan"
}

apply_automated_security_fixes() {
  local script_path="$1"
  local remediation_plan="$2"
  local backup_file="${script_path}.security_backup.$(date +%s)"
  
  # Create backup before applying fixes
  cp "$script_path" "$backup_file"
  log_info "Created security backup: $backup_file"
  
  # Apply automated fixes
  local automated_fixes
  automated_fixes=$(jq -r '.remediation_plan | to_entries[] | .value[] | select(.automated == true) | .fix_command' "$remediation_plan")
  
  while IFS= read -r fix_command; do
    if [[ "$fix_command" =~ ^sed|^awk|^perl ]]; then
      log_info "Applying automated fix: $fix_command"
      eval "$fix_command" || {
        log_error "Failed to apply fix: $fix_command"
        # Restore backup on failure
        cp "$backup_file" "$script_path"
        return 1
      }
    fi
  done <<< "$automated_fixes"
  
  # Validate script still works after fixes
  if bash -n "$script_path" >/dev/null 2>&1; then
    log_success "Automated security fixes applied successfully"
    # Keep backup for rollback if needed
    log_info "Backup available at: $backup_file"
  else
    log_error "Script syntax error after fixes - restoring backup"
    cp "$backup_file" "$script_path"
    return 1
  fi
}

generate_security_hardening_guide() {
  local script_path="$1"
  local hardening_guide="/tmp/security_hardening_guide_$(date +%s).md"
  
  cat > "$hardening_guide" << 'EOF'
# Security Hardening Guide

## Immediate Actions Required

### Critical Security Fixes
- [ ] Quote all variable expansions to prevent word splitting
- [ ] Replace hardcoded credentials with environment variables
- [ ] Implement input validation for all user inputs
- [ ] Use secure temporary file creation with mktemp

### Security Improvements
- [ ] Add error handling with proper cleanup
- [ ] Implement logging for security events
- [ ] Use absolute paths for all commands
- [ ] Add privilege validation checks

## Long-term Security Enhancements

### Access Control
- [ ] Implement role-based access control
- [ ] Add user authentication mechanisms
- [ ] Use principle of least privilege

### Monitoring and Auditing
- [ ] Add security event logging
- [ ] Implement intrusion detection
- [ ] Set up automated security scanning

### Secure Development Practices
- [ ] Implement code review process
- [ ] Add automated security testing
- [ ] Use static analysis tools
- [ ] Regular security training for developers

## Security Testing Checklist

### Static Analysis
- [ ] Run shellcheck for syntax issues
- [ ] Use bandit for security scanning
- [ ] Perform manual code review

### Dynamic Testing
- [ ] Test with malicious inputs
- [ ] Verify privilege escalation protection
- [ ] Test network security controls

### Compliance Verification
- [ ] CIS Benchmark compliance
- [ ] OWASP guidelines adherence
- [ ] Industry-specific requirements
EOF
  
  # Add script-specific recommendations
  add_script_specific_recommendations "$script_path" "$hardening_guide"
  
  echo "$hardening_guide"
}

add_script_specific_recommendations() {
  local script_path="$1"
  local hardening_guide="$2"
  
  echo "" >> "$hardening_guide"
  echo "## Script-Specific Recommendations" >> "$hardening_guide"
  echo "" >> "$hardening_guide"
  
  # Analyze script for specific security recommendations
  if grep -q "curl\|wget" "$script_path"; then
    cat >> "$hardening_guide" << 'EOF'
### Network Security
- [ ] Validate SSL certificates for all HTTPS connections
- [ ] Implement connection timeouts
- [ ] Use secure protocols only (HTTPS, SFTP, etc.)
- [ ] Validate downloaded file integrity with checksums
EOF
  fi
  
  if grep -q "sudo\|su " "$script_path"; then
    cat >> "$hardening_guide" << 'EOF'
### Privilege Management
- [ ] Minimize sudo usage to specific commands only
- [ ] Use sudoers file for fine-grained permissions
- [ ] Implement privilege escalation logging
- [ ] Add privilege validation before sensitive operations
EOF
  fi
  
  if grep -q "mysql\|psql\|sqlite" "$script_path"; then
    cat >> "$hardening_guide" << 'EOF'
### Database Security
- [ ] Use parameterized queries to prevent SQL injection
- [ ] Implement database connection encryption
- [ ] Use dedicated database users with minimal privileges
- [ ] Add database audit logging
EOF
  fi
}

# Comprehensive security remediation orchestrator
orchestrate_security_remediation() {
  local script_path="$1"
  local remediation_level="${2:-standard}" # basic, standard, comprehensive
  local auto_apply="${3:-false}"
  
  log_info "Starting security remediation orchestration for: $script_path"
  
  # Phase 1: Comprehensive security audit
  log_info "Phase 1: Performing comprehensive security audit..."
  local audit_results
  audit_results=$(perform_comprehensive_security_audit "$script_path")
  
  #
```
```bash
  # Phase 2: Generate remediation plan
  log_info "Phase 2: Generating security remediation plan..."
  local remediation_plan
  remediation_plan=$(generate_security_remediation_plan "$script_path" "$auto_apply")
  
  # Phase 3: Risk assessment and prioritization
  log_info "Phase 3: Performing risk assessment..."
  local risk_assessment
  risk_assessment=$(perform_security_risk_assessment "$script_path" "$remediation_plan")
  
  # Phase 4: Generate security hardening guide
  log_info "Phase 4: Creating security hardening guide..."
  local hardening_guide
  hardening_guide=$(generate_security_hardening_guide "$script_path")
  
  # Phase 5: Create implementation timeline
  log_info "Phase 5: Creating implementation timeline..."
  local implementation_timeline
  implementation_timeline=$(create_security_implementation_timeline "$remediation_plan" "$remediation_level")
  
  # Phase 6: Generate compliance report
  log_info "Phase 6: Generating compliance report..."
  local compliance_report
  compliance_report=$(generate_comprehensive_compliance_report "$script_path" "$remediation_plan")
  
  # Phase 7: Create monitoring and validation plan
  log_info "Phase 7: Setting up continuous security monitoring..."
  local monitoring_plan
  monitoring_plan=$(setup_continuous_security_monitoring "$script_path")
  
  # Generate final orchestration report
  local orchestration_report="/tmp/security_orchestration_$(date +%s).json"
  cat > "$orchestration_report" << EOF
{
  "orchestration_timestamp": "$(date -Iseconds)",
  "script_path": "$script_path",
  "remediation_level": "$remediation_level",
  "auto_apply_enabled": $auto_apply,
  "phases": {
    "audit_results": "$audit_results",
    "remediation_plan": "$remediation_plan",
    "risk_assessment": "$risk_assessment",
    "hardening_guide": "$hardening_guide",
    "implementation_timeline": "$implementation_timeline",
    "compliance_report": "$compliance_report",
    "monitoring_plan": "$monitoring_plan"
  },
  "next_steps": $(generate_next_steps_recommendations "$remediation_plan" | jq -R . | jq -s .),
  "estimated_completion_time": "$(calculate_remediation_timeline "$remediation_plan")",
  "security_score_improvement": "$(calculate_security_score_improvement "$script_path" "$remediation_plan")"
}
EOF
  
  log_success "Security remediation orchestration completed"
  log_info "Orchestration report: $orchestration_report"
  
  # Display summary
  display_remediation_summary "$orchestration_report"
  
  echo "$orchestration_report"
}

perform_security_risk_assessment() {
  local script_path="$1"
  local remediation_plan="$2"
  local risk_assessment="/tmp/security_risk_assessment_$(date +%s).json"
  
  # Calculate risk scores for different threat categories
  local confidentiality_risk
  confidentiality_risk=$(assess_confidentiality_risk "$script_path")
  
  local integrity_risk
  integrity_risk=$(assess_integrity_risk "$script_path")
  
  local availability_risk
  availability_risk=$(assess_availability_risk "$script_path")
  
  local compliance_risk
  compliance_risk=$(assess_compliance_risk "$script_path")
  
  # Calculate overall risk score using CIA triad
  local overall_risk_score
  overall_risk_score=$(echo "scale=2; ($confidentiality_risk + $integrity_risk + $availability_risk) / 3" | bc -l)
  
  # Determine risk level
  local risk_level
  if (( $(echo "$overall_risk_score >= 7.0" | bc -l) )); then
    risk_level="CRITICAL"
  elif (( $(echo "$overall_risk_score >= 5.0" | bc -l) )); then
    risk_level="HIGH"
  elif (( $(echo "$overall_risk_score >= 3.0" | bc -l) )); then
    risk_level="MEDIUM"
  else
    risk_level="LOW"
  fi
  
  # Generate risk assessment report
  cat > "$risk_assessment" << EOF
{
  "assessment_timestamp": "$(date -Iseconds)",
  "script_path": "$script_path",
  "risk_scores": {
    "confidentiality": $confidentiality_risk,
    "integrity": $integrity_risk,
    "availability": $availability_risk,
    "compliance": $compliance_risk,
    "overall": $overall_risk_score
  },
  "risk_level": "$risk_level",
  "threat_vectors": $(identify_threat_vectors "$script_path" | jq -R . | jq -s .),
  "attack_surface": $(calculate_attack_surface "$script_path"),
  "business_impact": $(assess_business_impact "$script_path"),
  "remediation_priority": $(prioritize_remediation_items "$remediation_plan")
}
EOF
  
  echo "$risk_assessment"
}

create_security_implementation_timeline() {
  local remediation_plan="$1"
  local remediation_level="$2"
  local timeline="/tmp/security_implementation_timeline_$(date +%s).json"
  
  # Extract remediation items and categorize by priority
  local critical_items
  critical_items=$(jq -r '.remediation_plan.critical_fixes[] | select(.priority == "critical") | .description' "$remediation_plan")
  
  local high_items
  high_items=$(jq -r '.remediation_plan.security_improvements[] | select(.priority == "high") | .description' "$remediation_plan")
  
  local medium_items
  medium_items=$(jq -r '.remediation_plan.hardening_recommendations[] | select(.priority == "medium") | .description' "$remediation_plan")
  
  # Create implementation phases based on priority and effort
  cat > "$timeline" << EOF
{
  "timeline_created": "$(date -Iseconds)",
  "remediation_level": "$remediation_level",
  "implementation_phases": {
    "immediate": {
      "timeframe": "0-24 hours",
      "description": "Critical security fixes that must be implemented immediately",
      "items": $(echo "$critical_items" | jq -R . | jq -s .),
      "estimated_effort": "2-4 hours"
    },
    "short_term": {
      "timeframe": "1-7 days",
      "description": "High-priority security improvements",
      "items": $(echo "$high_items" | jq -R . | jq -s .),
      "estimated_effort": "8-16 hours"
    },
    "medium_term": {
      "timeframe": "1-4 weeks",
      "description": "Security hardening and process improvements",
      "items": $(echo "$medium_items" | jq -R . | jq -s .),
      "estimated_effort": "16-32 hours"
    },
    "long_term": {
      "timeframe": "1-3 months",
      "description": "Comprehensive security program implementation",
      "items": [
        "Implement continuous security monitoring",
        "Establish security training program",
        "Deploy automated security testing",
        "Create incident response procedures"
      ],
      "estimated_effort": "40-80 hours"
    }
  },
  "milestones": [
    {
      "name": "Critical Vulnerabilities Resolved",
      "target_date": "$(date -d '+1 day' -Iseconds)",
      "success_criteria": "All critical security issues remediated"
    },
    {
      "name": "Security Hardening Complete",
      "target_date": "$(date -d '+1 week' -Iseconds)",
      "success_criteria": "Security score improved by 50%"
    },
    {
      "name": "Compliance Achieved",
      "target_date": "$(date -d '+1 month' -Iseconds)",
      "success_criteria": "All compliance requirements met"
    }
  ]
}
EOF
  
  echo "$timeline"
}

setup_continuous_security_monitoring() {
  local script_path="$1"
  local monitoring_plan="/tmp/security_monitoring_plan_$(date +%s).json"
  
  # Create comprehensive monitoring configuration
  cat > "$monitoring_plan" << EOF
{
  "monitoring_setup_timestamp": "$(date -Iseconds)",
  "script_path": "$script_path",
  "monitoring_components": {
    "static_analysis": {
      "enabled": true,
      "frequency": "daily",
      "tools": ["shellcheck", "bandit", "semgrep"],
      "alert_threshold": "medium"
    },
    "dynamic_analysis": {
      "enabled": true,
      "frequency": "weekly",
      "monitoring_points": [
        "file_system_access",
        "network_connections",
        "privilege_escalation",
        "process_execution"
      ]
    },
    "compliance_monitoring": {
      "enabled": true,
      "frequency": "monthly",
      "frameworks": ["CIS", "NIST", "OWASP"],
      "automated_reporting": true
    },
    "threat_detection": {
      "enabled": true,
      "frequency": "real-time",
      "detection_methods": [
        "behavioral_analysis",
        "signature_matching",
        "anomaly_detection",
        "machine_learning"
      ]
    }
  },
  "alerting_configuration": {
    "critical_alerts": {
      "delivery_method": "immediate",
      "channels": ["email", "slack", "pagerduty"]
    },
    "warning_alerts": {
      "delivery_method": "batched",
      "frequency": "hourly"
    }
  },
  "reporting_schedule": {
    "daily_summary": "08:00 UTC",
    "weekly_report": "Monday 09:00 UTC",
    "monthly_compliance": "1st of month 10:00 UTC"
  }
}
EOF
  
  # Setup monitoring scripts and configurations
  create_monitoring_scripts "$script_path" "$monitoring_plan"
  
  echo "$monitoring_plan"
}

display_remediation_summary() {
  local orchestration_report="$1"
  
  echo ""
  echo "🔒 SECURITY REMEDIATION SUMMARY"
  echo "================================"
  
  # Extract key metrics from orchestration report
  local script_path
  script_path=$(jq -r '.script_path' "$orchestration_report")
  
  local remediation_level
  remediation_level=$(jq -r '.remediation_level' "$orchestration_report")
  
  local estimated_completion
  estimated_completion=$(jq -r '.estimated_completion_time' "$orchestration_report")
  
  local security_improvement
  security_improvement=$(jq -r '.security_score_improvement' "$orchestration_report")
  
  echo "📄 Script: $script_path"
  echo "🎯 Remediation Level: $remediation_level"
  echo "⏱️  Estimated Completion: $estimated_completion"
  echo "📈 Security Score Improvement: +$security_improvement%"
  echo ""
  
  # Display next steps
  echo "🚀 IMMEDIATE NEXT STEPS:"
  local next_steps
  next_steps=$(jq -r '.next_steps[]' "$orchestration_report")
  echo "$next_steps" | sed 's/^/  • /'
  
  echo ""
  echo "📊 DETAILED REPORTS GENERATED:"
  echo "  • Remediation Plan: $(jq -r '.phases.remediation_plan' "$orchestration_report")"
  echo "  • Risk Assessment: $(jq -r '.phases.risk_assessment' "$orchestration_report")"
  echo "  • Hardening Guide: $(jq -r '.phases.hardening_guide' "$orchestration_report")"
  echo "  • Implementation Timeline: $(jq -r '.phases.implementation_timeline' "$orchestration_report")"
  echo "  • Compliance Report: $(jq -r '.phases.compliance_report' "$orchestration_report")"
  echo "  • Monitoring Plan: $(jq -r '.phases.monitoring_plan' "$orchestration_report")"
  echo ""
}
```

---

## **Summary**

The `.github/prompts/security-audit.prompt.md` file provides a solid foundation for shell script security auditing, but it has significant gaps that limit its effectiveness in modern threat landscapes. The five key areas for improvement identified are:

### **Critical Enhancements Needed:**

1. **Dynamic Security Analysis**: The current prompt focuses on static analysis but misses runtime vulnerabilities, behavioral anomalies, and sophisticated attack patterns that only manifest during execution.

2. **Automated Policy Enforcement**: Lacks integration with compliance frameworks (CIS, NIST, OWASP) and automated policy validation, which are essential for enterprise security standards.

3. **Supply Chain Security**: Missing comprehensive dependency vulnerability scanning, package integrity validation, and external resource security verification.

4. **Advanced Threat Detection**: Needs sophisticated threat detection capabilities including obfuscation detection, evasion technique identification, and machine learning-inspired behavioral analysis.

5. **Automated Remediation**: Currently provides manual checklists but lacks automated fix generation, remediation orchestration, and continuous security monitoring capabilities.

### **Overall Assessment:**

While the original prompt covers basic security audit patterns, it falls short of providing a comprehensive, enterprise-grade security framework. The enhanced version transforms it into a sophisticated security orchestration platform that:

- **Provides 360-degree security coverage** from static analysis to runtime monitoring
- **Integrates with modern compliance frameworks** and industry standards
- **Offers automated remediation capabilities** with risk-based prioritization
- **Includes advanced threat detection** using behavioral analysis and machine learning techniques
- **Supports continuous security monitoring** with real-time alerting and reporting

The enhanced framework elevates shell script security from basic vulnerability detection to comprehensive security program management, making it suitable for production environments with strict security requirements and compliance obligations.

**Recommendation**: Implement these enhancements to create a world-class security auditing framework that addresses modern threat landscapes and enterprise security needs.