Looking at the `util-install.sh` script, I can identify several areas for improvement that would enhance security, robustness, and maintainability:

## **1. Enhanced Security Validation and Input Sanitization**

**Issue**: The script lacks comprehensive input validation and sanitization, particularly for URLs, package names, and file paths that could be exploited for injection attacks.

**Recommendation**:
```bash:util-install.sh
# Enhanced security validation functions
validate_package_name() {
  local package="$1"
  local context="${2:-general}"
  
  # Check for empty input
  if [[ -z "$package" ]]; then
    log_error "Package name cannot be empty"
    return 1
  fi
  
  # Basic package name validation (alphanumeric, hyphens, dots, plus)
  if [[ ! "$package" =~ ^[a-zA-Z0-9][a-zA-Z0-9\.\-\+]*$ ]]; then
    log_error "Invalid package name format: $package"
    return 1
  fi
  
  # Length validation
  if [[ ${#package} -gt 214 ]]; then  # Debian package name limit
    log_error "Package name too long: $package"
    return 1
  fi
  
  # Context-specific validation
  case "$context" in
    "snap")
      # Snap packages can have different naming conventions
      if [[ ! "$package" =~ ^[a-z0-9]([a-z0-9\-]*[a-z0-9])?$ ]]; then
        log_error "Invalid snap package name: $package"
        return 1
      fi
      ;;
    "deb_url")
      # Additional validation for .deb URLs
      if [[ ! "$package" =~ \.deb$ ]]; then
        log_error "URL must point to a .deb file: $package"
        return 1
      fi
      ;;
  esac
  
  return 0
}

validate_url() {
  local url="$1"
  local allowed_schemes="${2:-https http}"
  
  # Check for empty URL
  if [[ -z "$url" ]]; then
    log_error "URL cannot be empty"
    return 1
  fi
  
  # Basic URL format validation
  if [[ ! "$url" =~ ^[a-zA-Z][a-zA-Z0-9+.-]*:// ]]; then
    log_error "Invalid URL format: $url"
    return 1
  fi
  
  # Extract and validate scheme
  local scheme="${url%%://*}"
  if [[ ! " $allowed_schemes " =~ " $scheme " ]]; then
    log_error "URL scheme not allowed: $scheme (allowed: $allowed_schemes)"
    return 1
  fi
  
  # Check for suspicious characters
  if [[ "$url" =~ [[:space:]\;\&\|\`\$\(\)] ]]; then
    log_error "URL contains suspicious characters: $url"
    return 1
  fi
  
  # Length validation (reasonable URL length)
  if [[ ${#url} -gt 2048 ]]; then
    log_error "URL too long: $url"
    return 1
  fi
  
  return 0
}

sanitize_file_path() {
  local path="$1"
  local base_dir="${2:-/tmp}"
  
  # Remove any path traversal attempts
  path="${path//..\/}"
  path="${path//\.\.\\}"
  
  # Ensure path is within base directory
  local canonical_path
  canonical_path="$(readlink -f "$base_dir/$path" 2>/dev/null)" || {
    log_error "Cannot resolve path: $path"
    return 1
  }
  
  local canonical_base
  canonical_base="$(readlink -f "$base_dir" 2>/dev/null)" || {
    log_error "Cannot resolve base directory: $base_dir"
    return 1
  }
  
  if [[ ! "$canonical_path" =~ ^"$canonical_base" ]]; then
    log_error "Path outside allowed directory: $path"
    return 1
  fi
  
  echo "$canonical_path"
}

# Enhanced safe_apt_install with validation
safe_apt_install() {
  init_logging
  local packages=("$@")
  local failed_packages=()
  local validated_packages=()
  
  # Validate all package names first
  for pkg in "${packages[@]}"; do
    if validate_package_name "$pkg" "apt"; then
      validated_packages+=("$pkg")
    else
      log_error "Skipping invalid package name: $pkg"
      failed_packages+=("$pkg")
    fi
  done
  
  if [[ ${#validated_packages[@]} -eq 0 ]]; then
    log_error "No valid packages to install"
    finish_logging
    return 1
  fi
  
  update_package_index
  
  for pkg in "${validated_packages[@]}"; do
    log_info "Installing $pkg..."
    
    # Use timeout and restrict environment for security
    if timeout 300 sudo -E env PATH="/usr/bin:/bin:/usr/sbin:/sbin" \
       DEBIAN_FRONTEND=noninteractive apt-get install -y \
       -o DPkg::Lock::Timeout=30 \
       -o APT::Get::AllowUnauthenticated=false \
       "$pkg" 2>/dev/null; then
      log_success "Installed $pkg"
    else
      log_warning "Could not install $pkg - may not be available in this Ubuntu version"
      failed_packages+=("$pkg")
    fi
  done
  
  if [ ${#failed_packages[@]} -gt 0 ]; then
    log_warning "Failed to install: ${failed_packages[*]}"
    finish_logging
    return 1
  fi
  
  finish_logging
  return 0
}

# Enhanced safe_install_deb with comprehensive validation
safe_install_deb() {
  init_logging
  local url="$1"
  local pkg_name="${2:-$(basename "$url" .deb)}"
  
  # Validate URL
  if ! validate_url "$url" "https"; then
    log_error "Invalid or insecure URL provided"
    finish_logging
    return 1
  fi
  
  # Validate package name
  if ! validate_package_name "$pkg_name" "deb_url"; then
    log_error "Invalid package name derived from URL"
    finish_logging
    return 1
  fi
  
  # Create secure temporary file
  local temp_file
  temp_file=$(sanitize_file_path "${pkg_name}_$(date +%s).deb" "/tmp") || {
    log_error "Cannot create secure temporary file path"
    finish_logging
    return 1
  }
  
  log_info "Downloading $pkg_name from $url..."
  
  # Download with security restrictions
  if timeout 300 wget \
     --secure-protocol=TLSv1_2 \
     --no-check-certificate=false \
     --max-redirect=3 \
     --user-agent="Ubuntu-Dev-Setup/1.0" \
     --progress=dot:giga \
     -O "$temp_file" "$url"; then
    log_success "Download complete"
    
    # Verify file is actually a .deb package
    if ! file "$temp_file" | grep -q "Debian binary package"; then
      log_error "Downloaded file is not a valid Debian package"
      rm -f "$temp_file"
      finish_logging
      return 1
    fi
    
    log_info "Installing $pkg_name..."
    if timeout 300 sudo apt install -y "$temp_file"; then
      log_success "Successfully installed $pkg_name"
      rm -f "$temp_file"
      finish_logging
      return 0
    else
      log_error "Failed to install $pkg_name"
      rm -f "$temp_file"
      finish_logging
      return 1
    fi
  else
    log_error "Failed to download $pkg_name"
    rm -f "$temp_file"
    finish_logging
    return 1
  fi
}
```

**Benefits**: Prevents injection attacks, validates input integrity, ensures secure file handling, and provides comprehensive error reporting for security issues.

## **2. Advanced Package Dependency Resolution and Conflict Detection**

**Issue**: The current installation functions don't check for package conflicts, dependencies, or provide rollback capabilities when installations fail.

**Recommendation**:
```bash:util-install.sh
# Advanced package management with dependency resolution
declare -A INSTALLATION_HISTORY=()
declare -A PACKAGE_DEPENDENCIES=()

safe_apt_install_with_deps() {
  init_logging
  local packages=("$@")
  local installation_plan=()
  local rollback_plan=()
  
  # Create installation plan with dependency resolution
  if ! create_installation_plan installation_plan "${packages[@]}"; then
    log_error "Failed to create installation plan"
    finish_logging
    return 1
  fi
  
  log_info "Installation plan created: ${installation_plan[*]}"
  
  # Check for conflicts before installation
  if ! check_package_conflicts "${installation_plan[@]}"; then
    log_error "Package conflicts detected, aborting installation"
    finish_logging
    return 1
  fi
  
  # Perform installation with rollback capability
  local installed_packages=()
  local failed=false
  
  for pkg in "${installation_plan[@]}"; do
    log_info "Installing $pkg..."
    
    # Record pre-installation state
    local was_installed=false
    if is_package_installed "$pkg"; then
      was_installed=true
    fi
    
    if install_single_package "$pkg"; then
      log_success "Installed $pkg"
      installed_packages+=("$pkg")
      INSTALLATION_HISTORY["$pkg"]="$(date +%s)"
      
      if [[ "$was_installed" == "false" ]]; then
        rollback_plan+=("$pkg")
      fi
    else
      log_error "Failed to install $pkg"
      failed=true
      break
    fi
  done
  
  # Handle rollback if installation failed
  if [[ "$failed" == "true" ]]; then
    log_warning "Installation failed, initiating rollback..."
    rollback_installation "${rollback_plan[@]}"
    finish_logging
    return 1
  fi
  
  log_success "All packages installed successfully"
  finish_logging
  return 0
}

create_installation_plan() {
  local -n plan_ref=$1
  shift
  local packages=("$@")
  local resolved_packages=()
  
  # Get dependencies for each package
  for pkg in "${packages[@]}"; do
    local deps
    if ! deps=$(get_package_dependencies "$pkg"); then
      log_error "Failed to resolve dependencies for $pkg"
      return 1
    fi
    
    # Add dependencies to resolved list
    while IFS= read -r dep; do
      [[ -n "$dep" ]] && resolved_packages+=("$dep")
    done <<< "$deps"
    
    # Add the package itself
    resolved_packages+=("$pkg")
  done
  
  # Remove duplicates and sort by dependency order
  local unique_packages
  readarray -t unique_packages < <(printf '%s\n' "${resolved_packages[@]}" | sort -u)
  
  # Topological sort for dependency order
  if ! topological_sort plan_ref "${unique_packages[@]}"; then
    log_error "Circular dependency detected"
    return 1
  fi
  
  return 0
}

get_package_dependencies() {
  local package="$1"
  local cache_file="/tmp/deps_${package//\//_}"
  local cache_ttl=3600  # 1 hour
  
  # Check cache
  if [[ -f "$cache_file" ]] && [[ $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $cache_ttl ]]; then
    cat "$cache_file"
    return 0
  fi
  
  # Query package dependencies
  local deps
  if deps=$(apt-cache depends "$package" 2>/dev/null | grep "Depends:" | awk '{print $2}' | grep -v "^<"); then
    echo "$deps" | tee "$cache_file"
    return 0
  else
    # If apt-cache fails, return empty (no dependencies)
    touch "$cache_file"
    return 0
  fi
}

check_package_conflicts() {
  local packages=("$@")
  local conflicts_found=false
  
  for pkg in "${packages[@]}"; do
    # Check for conflicts with already installed packages
    local conflicts
    if conflicts=$(apt-cache show "$pkg" 2>/dev/null | grep "^Conflicts:" | cut -d: -f2 | tr ',' '\n' | sed 's/^ *//'); then
      while IFS= read -r conflict; do
        [[ -z "$conflict" ]] && continue
        
        # Remove version constraints for simple check
        local conflict_pkg="${conflict%% *}"
        
        if is_package_installed "$conflict_pkg"; then
          log_error "Package $pkg conflicts with installed package: $conflict_pkg"
          conflicts_found=true
        fi
      done <<< "$conflicts"
    fi
    
    # Check for conflicts between packages in the installation list
    for other_pkg in "${packages[@]}"; do
      [[ "$pkg" == "$other_pkg" ]] && continue
      
      if packages_conflict "$pkg" "$other_pkg"; then
        log_error "Packages $pkg and $other_pkg conflict with each other"
        conflicts_found=true
      fi
    done
  done
  
  [[ "$conflicts_found" == "false" ]]
}

packages_conflict() {
  local pkg1="$1"
  local pkg2="$2"
  
  # Simple conflict check - in practice, this would be more sophisticated
  local conflicts1 conflicts2
  conflicts1=$(apt-cache show "$pkg1" 2>/dev/null | grep "^Conflicts:" | cut -d: -f2 || echo "")
  conflicts2=$(apt-cache show "$pkg2" 2>/dev/null | grep "^Conflicts:" | cut -d: -f2 || echo "")
  
  # Check if pkg1 conflicts with pkg2
  if [[ "$conflicts1" =~ $pkg2 ]]; then
    return 0  # Conflict found
  fi
  
  # Check if pkg2 conflicts with pkg1
  if [[ "$conflicts2" =~ $pkg1 ]]; then
    return 0  # Conflict found
  fi
  
  return 1  # No conflict
}

rollback_installation() {
  local packages=("$@")
  
  log_info "Rolling back installation of packages: ${packages[*]}"
  
  # Remove packages in reverse order
  local i
  for ((i=${#packages[@]}-1; i>=0; i--)); do
    local pkg="${packages[i]}"
    log_info "Removing $pkg..."
    
    if sudo apt-get remove -y "$pkg" >/dev/null 2>&1; then
      log_success "Removed $pkg"
      unset INSTALLATION_HISTORY["$pkg"]
    else
      log_warning "Failed to remove $pkg during rollback"
    fi
  done
  
  # Clean up orphaned dependencies
  log_info "Cleaning up orphaned dependencies..."
  sudo apt-get autoremove -y >/dev/null 2>&1 || true
}

install_single_package() {
  local pkg="$1"
  local max_attempts=3
  local attempt=1
  
  while [[ $attempt -le $max_attempts ]]; do
    if timeout 300 sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
       -o DPkg::
```
```bash:util-install.sh
install_single_package() {
  local pkg="$1"
  local max_attempts=3
  local attempt=1
  
  while [[ $attempt -le $max_attempts ]]; do
    if timeout 300 sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
       -o DPkg::Lock::Timeout=30 \
       -o APT::Get::AllowUnauthenticated=false \
       -o APT::Install-Recommends=false \
       "$pkg" >/dev/null 2>&1; then
      return 0
    else
      local exit_code=$?
      log_warning "Installation attempt $attempt failed for $pkg (exit code: $exit_code)"
      
      if [[ $attempt -lt $max_attempts ]]; then
        log_info "Retrying in $((attempt * 2)) seconds..."
        sleep $((attempt * 2))
        
        # Try to fix broken packages before retry
        sudo apt-get install -f -y >/dev/null 2>&1 || true
      fi
      
      ((attempt++))
    fi
  done
  
  return 1
}

topological_sort() {
  local -n sorted_ref=$1
  shift
  local packages=("$@")
  
  # Simple topological sort implementation
  # In practice, this would need a more sophisticated dependency graph
  local visited=()
  local temp_mark=()
  local perm_mark=()
  
  for pkg in "${packages[@]}"; do
    if [[ ! " ${perm_mark[*]} " =~ " $pkg " ]]; then
      if ! visit_package "$pkg" visited temp_mark perm_mark sorted_ref; then
        return 1  # Circular dependency
      fi
    fi
  done
  
  return 0
}

visit_package() {
  local pkg="$1"
  local -n visited_ref=$2
  local -n temp_ref=$3
  local -n perm_ref=$4
  local -n result_ref=$5
  
  if [[ " ${temp_ref[*]} " =~ " $pkg " ]]; then
    return 1  # Circular dependency
  fi
  
  if [[ " ${perm_ref[*]} " =~ " $pkg " ]]; then
    return 0  # Already processed
  fi
  
  temp_ref+=("$pkg")
  
  # Visit dependencies (simplified - would need actual dependency resolution)
  local deps
  deps=$(get_package_dependencies "$pkg")
  while IFS= read -r dep; do
    [[ -n "$dep" ]] && visit_package "$dep" visited_ref temp_ref perm_ref result_ref
  done <<< "$deps"
  
  # Remove from temporary mark
  local new_temp=()
  for item in "${temp_ref[@]}"; do
    [[ "$item" != "$pkg" ]] && new_temp+=("$item")
  done
  temp_ref=("${new_temp[@]}")
  
  perm_ref+=("$pkg")
  result_ref+=("$pkg")
  
  return 0
}
```

**Benefits**: Prevents broken installations due to dependency conflicts, provides automatic rollback on failure, improves installation success rates, and maintains system consistency.

## **3. Comprehensive Installation State Management and Recovery**

**Issue**: The script lacks persistent state management for tracking installations, handling interrupted installations, and providing recovery mechanisms.

**Recommendation**:
```bash:util-install.sh
# Installation state management
readonly STATE_DIR="${HOME}/.ubuntu-dev-setup"
readonly INSTALLATION_LOG="${STATE_DIR}/installation.log"
readonly STATE_FILE="${STATE_DIR}/installation.state"
readonly LOCK_FILE="${STATE_DIR}/installation.lock"

# Initialize state management
init_installation_state() {
  mkdir -p "$STATE_DIR"
  
  # Check for existing lock file (interrupted installation)
  if [[ -f "$LOCK_FILE" ]]; then
    local lock_pid
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
      log_error "Another installation is already running (PID: $lock_pid)"
      return 1
    else
      log_warning "Found stale lock file, cleaning up..."
      rm -f "$LOCK_FILE"
      
      # Check for interrupted installation
      if [[ -f "${STATE_FILE}.tmp" ]]; then
        log_info "Found interrupted installation, offering recovery..."
        offer_installation_recovery
      fi
    fi
  fi
  
  # Create lock file
  echo $$ > "$LOCK_FILE"
  
  # Initialize state file if it doesn't exist
  [[ ! -f "$STATE_FILE" ]] && echo "{}" > "$STATE_FILE"
  
  return 0
}

cleanup_installation_state() {
  local exit_code=$?
  
  # Remove lock file
  rm -f "$LOCK_FILE"
  
  # Finalize state file if temporary exists
  if [[ -f "${STATE_FILE}.tmp" ]]; then
    if [[ $exit_code -eq 0 ]]; then
      mv "${STATE_FILE}.tmp" "$STATE_FILE"
    else
      log_warning "Installation failed, preserving temporary state for recovery"
    fi
  fi
  
  return $exit_code
}

# Set up cleanup trap
trap cleanup_installation_state EXIT INT TERM

record_installation_start() {
  local component="$1"
  local packages=("${@:2}")
  
  # Create temporary state file
  local temp_state
  temp_state=$(mktemp "${STATE_FILE}.XXXXXX")
  
  # Read current state
  local current_state="{}"
  [[ -f "$STATE_FILE" ]] && current_state=$(cat "$STATE_FILE")
  
  # Add new installation record
  local timestamp
  timestamp=$(date -Iseconds)
  
  local packages_json
  packages_json=$(printf '"%s",' "${packages[@]}")
  packages_json="[${packages_json%,}]"
  
  # Update state using jq if available, otherwise use simple JSON manipulation
  if command -v jq >/dev/null 2>&1; then
    echo "$current_state" | jq \
      --arg component "$component" \
      --arg timestamp "$timestamp" \
      --argjson packages "$packages_json" \
      '.installations[$component] = {
        "status": "in_progress",
        "started": $timestamp,
        "packages": $packages,
        "attempts": (.installations[$component].attempts // 0) + 1
      }' > "$temp_state"
  else
    # Fallback JSON manipulation
    {
      echo "$current_state" | sed 's/}$//'
      echo ",\"installations\":{\"$component\":{\"status\":\"in_progress\",\"started\":\"$timestamp\",\"packages\":$packages_json,\"attempts\":1}}"
      echo "}"
    } | tr -d '\n' > "$temp_state"
  fi
  
  mv "$temp_state" "${STATE_FILE}.tmp"
  
  # Log the start
  echo "$(date -Iseconds) START $component ${packages[*]}" >> "$INSTALLATION_LOG"
}

record_installation_success() {
  local component="$1"
  
  if [[ ! -f "${STATE_FILE}.tmp" ]]; then
    log_warning "No temporary state file found for $component"
    return 1
  fi
  
  local temp_state
  temp_state=$(mktemp "${STATE_FILE}.XXXXXX")
  
  local timestamp
  timestamp=$(date -Iseconds)
  
  # Update status to completed
  if command -v jq >/dev/null 2>&1; then
    cat "${STATE_FILE}.tmp" | jq \
      --arg component "$component" \
      --arg timestamp "$timestamp" \
      '.installations[$component].status = "completed" |
       .installations[$component].completed = $timestamp' > "$temp_state"
  else
    # Fallback - simple sed replacement
    sed "s/\"status\":\"in_progress\"/\"status\":\"completed\",\"completed\":\"$timestamp\"/" \
      "${STATE_FILE}.tmp" > "$temp_state"
  fi
  
  mv "$temp_state" "${STATE_FILE}.tmp"
  
  # Log the success
  echo "$(date -Iseconds) SUCCESS $component" >> "$INSTALLATION_LOG"
}

record_installation_failure() {
  local component="$1"
  local error_message="$2"
  
  if [[ ! -f "${STATE_FILE}.tmp" ]]; then
    log_warning "No temporary state file found for $component"
    return 1
  fi
  
  local temp_state
  temp_state=$(mktemp "${STATE_FILE}.XXXXXX")
  
  local timestamp
  timestamp=$(date -Iseconds)
  
  # Update status to failed
  if command -v jq >/dev/null 2>&1; then
    cat "${STATE_FILE}.tmp" | jq \
      --arg component "$component" \
      --arg timestamp "$timestamp" \
      --arg error "$error_message" \
      '.installations[$component].status = "failed" |
       .installations[$component].failed = $timestamp |
       .installations[$component].error = $error' > "$temp_state"
  else
    # Fallback - simple sed replacement
    sed "s/\"status\":\"in_progress\"/\"status\":\"failed\",\"failed\":\"$timestamp\",\"error\":\"$error_message\"/" \
      "${STATE_FILE}.tmp" > "$temp_state"
  fi
  
  mv "$temp_state" "${STATE_FILE}.tmp"
  
  # Log the failure
  echo "$(date -Iseconds) FAILED $component $error_message" >> "$INSTALLATION_LOG"
}

offer_installation_recovery() {
  if [[ ! -f "${STATE_FILE}.tmp" ]]; then
    return 0
  fi
  
  log_info "Interrupted installation detected. Recovery options:"
  echo "1. Resume interrupted installation"
  echo "2. Rollback interrupted installation"
  echo "3. Start fresh installation"
  
  local choice
  read -p "Choose option (1-3): " choice
  
  case "$choice" in
    1)
      log_info "Resuming interrupted installation..."
      resume_interrupted_installation
      ;;
    2)
      log_info "Rolling back interrupted installation..."
      rollback_interrupted_installation
      ;;
    3)
      log_info "Starting fresh installation..."
      rm -f "${STATE_FILE}.tmp"
      ;;
    *)
      log_warning "Invalid choice, starting fresh installation..."
      rm -f "${STATE_FILE}.tmp"
      ;;
  esac
}

resume_interrupted_installation() {
  if [[ ! -f "${STATE_FILE}.tmp" ]]; then
    log_error "No interrupted installation state found"
    return 1
  fi
  
  # Parse interrupted state and resume
  local interrupted_components
  if command -v jq >/dev/null 2>&1; then
    interrupted_components=$(cat "${STATE_FILE}.tmp" | jq -r '.installations | to_entries[] | select(.value.status == "in_progress") | .key')
  else
    # Fallback parsing
    interrupted_components=$(grep -o '"[^"]*":{"status":"in_progress"' "${STATE_FILE}.tmp" | cut -d'"' -f2)
  fi
  
  if [[ -z "$interrupted_components" ]]; then
    log_info "No interrupted installations found"
    return 0
  fi
  
  log_info "Resuming interrupted components: $interrupted_components"
  
  # This would integrate with the main installation logic
  # Implementation depends on how the main installer is structured
  
  return 0
}

rollback_interrupted_installation() {
  if [[ ! -f "${STATE_FILE}.tmp" ]]; then
    log_error "No interrupted installation state found"
    return 1
  fi
  
  # Get packages that were being installed
  local packages_to_remove=()
  
  if command -v jq >/dev/null 2>&1; then
    while IFS= read -r package; do
      [[ -n "$package" ]] && packages_to_remove+=("$package")
    done < <(cat "${STATE_FILE}.tmp" | jq -r '.installations[] | select(.status == "in_progress") | .packages[]?')
  else
    # Fallback parsing - more complex without jq
    log_warning "jq not available, manual rollback may be required"
    return 1
  fi
  
  if [[ ${#packages_to_remove[@]} -gt 0 ]]; then
    log_info "Rolling back packages: ${packages_to_remove[*]}"
    rollback_installation "${packages_to_remove[@]}"
  fi
  
  # Clean up interrupted state
  rm -f "${STATE_FILE}.tmp"
  
  return 0
}

get_installation_history() {
  local format="${1:-text}"  # text, json
  
  if [[ ! -f "$STATE_FILE" ]]; then
    case "$format" in
      "json") echo "{}" ;;
      "text") echo "No installation history found" ;;
    esac
    return 0
  fi
  
  case "$format" in
    "json")
      cat "$STATE_FILE"
      ;;
    "text")
      if command -v jq >/dev/null 2>&1; then
        echo "Installation History:"
        echo "===================="
        cat "$STATE_FILE" | jq -r '
          .installations // {} | to_entries[] |
          "\(.key): \(.value.status) (started: \(.value.started // "unknown"))"
        '
      else
        echo "Installation history available in: $STATE_FILE"
        echo "Install jq for formatted output"
      fi
      ;;
  esac
}

# Enhanced installation wrapper with state management
safe_install_with_state() {
  local component="$1"
  shift
  local packages=("$@")
  
  # Initialize state management
  if ! init_installation_state; then
    return 1
  fi
  
  # Record installation start
  record_installation_start "$component" "${packages[@]}"
  
  # Perform installation
  if safe_apt_install_with_deps "${packages[@]}"; then
    record_installation_success "$component"
    log_success "Successfully installed $component"
    return 0
  else
    record_installation_failure "$component" "Installation failed"
    log_error "Failed to install $component"
    return 1
  fi
}
```

**Benefits**: Provides recovery from interrupted installations, maintains comprehensive installation history, enables rollback of partial installations, and improves reliability in unstable environments.

## **4. Performance Optimization and Resource Management**

**Issue**: The script performs many redundant operations, lacks caching mechanisms, and doesn't optimize for system resources during bulk installations.

**Recommendation**:
```bash:util-install.sh
# Performance optimization and caching
readonly CACHE_DIR="${HOME}/.ubuntu-dev-setup/cache"
readonly PACKAGE_CACHE_TTL=3600  # 1 hour
readonly MAX_PARALLEL_DOWNLOADS=4
readonly DOWNLOAD_TIMEOUT=300

# Initialize performance optimizations
init_performance_optimizations() {
  mkdir -p "$CACHE_DIR"
  
  # Set up package manager optimizations
  setup_apt_optimizations
  
  # Initialize download manager
  init_download_manager
  
  # Set up resource monitoring
  init_resource_monitoring
}

setup_apt_optimizations() {
  # Configure APT for better performance
  local apt_conf="/etc/apt/apt.conf.d/99ubuntu-dev-setup"
  
  if [[ ! -f "$apt_conf" ]]; then
    sudo t
```
```bash:util-install.sh
setup_apt_optimizations() {
  # Configure APT for better performance
  local apt_conf="/etc/apt/apt.conf.d/99ubuntu-dev-setup"
  
  if [[ ! -f "$apt_conf" ]]; then
    sudo tee "$apt_conf" > /dev/null << 'EOF'
// Ubuntu Dev Setup APT Optimizations
APT::Acquire::Retries "3";
APT::Acquire::http::Timeout "30";
APT::Acquire::https::Timeout "30";
APT::Acquire::ftp::Timeout "30";
APT::Get::Assume-Yes "false";
APT::Get::Fix-Broken "true";
APT::Install-Recommends "false";
APT::Install-Suggests "false";
Dpkg::Use-Pty "0";
EOF
    log_info "APT optimizations configured"
  fi
  
  # Set up parallel downloads if supported
  if apt-config dump | grep -q "Acquire::Queue-Mode"; then
    echo 'APT::Acquire::Queue-Mode "host";' | sudo tee -a "$apt_conf" > /dev/null
    echo 'APT::Acquire::Retries "2";' | sudo tee -a "$apt_conf" > /dev/null
  fi
}

init_download_manager() {
  # Create download queue and worker management
  local download_queue="${CACHE_DIR}/download_queue"
  local download_workers="${CACHE_DIR}/download_workers"
  
  mkdir -p "$(dirname "$download_queue")"
  touch "$download_queue"
  echo "0" > "$download_workers"
}

init_resource_monitoring() {
  # Monitor system resources during installation
  local monitor_interval=5
  
  # Start resource monitor in background
  {
    while [[ -f "${CACHE_DIR}/installation_active" ]]; do
      local memory_usage disk_usage load_avg
      memory_usage=$(get_memory_usage_percentage)
      disk_usage=$(get_disk_usage_percentage)
      load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
      
      # Log resource usage
      echo "$(date -Iseconds) RESOURCES memory:${memory_usage}% disk:${disk_usage}% load:${load_avg}" >> "${CACHE_DIR}/resource_monitor.log"
      
      # Throttle if system is under heavy load
      if (( $(echo "$load_avg > $(nproc)" | bc -l 2>/dev/null || echo "0") )); then
        log_info "High system load detected ($load_avg), throttling installations..."
        sleep $((monitor_interval * 2))
      fi
      
      sleep $monitor_interval
    done
  } &
  
  echo $! > "${CACHE_DIR}/monitor_pid"
}

stop_resource_monitoring() {
  rm -f "${CACHE_DIR}/installation_active"
  
  if [[ -f "${CACHE_DIR}/monitor_pid" ]]; then
    local monitor_pid
    monitor_pid=$(cat "${CACHE_DIR}/monitor_pid")
    if kill -0 "$monitor_pid" 2>/dev/null; then
      kill "$monitor_pid" 2>/dev/null || true
    fi
    rm -f "${CACHE_DIR}/monitor_pid"
  fi
}

# Cached package information functions
get_cached_package_info() {
  local package="$1"
  local info_type="${2:-basic}"  # basic, dependencies, conflicts
  local cache_file="${CACHE_DIR}/pkg_${package//\//_}_${info_type}"
  
  # Check cache validity
  if [[ -f "$cache_file" ]] && [[ $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $PACKAGE_CACHE_TTL ]]; then
    cat "$cache_file"
    return 0
  fi
  
  # Fetch and cache package information
  local info
  case "$info_type" in
    "basic")
      info=$(apt-cache show "$package" 2>/dev/null)
      ;;
    "dependencies")
      info=$(apt-cache depends "$package" 2>/dev/null)
      ;;
    "conflicts")
      info=$(apt-cache show "$package" 2>/dev/null | grep "^Conflicts:")
      ;;
    *)
      log_error "Unknown info type: $info_type"
      return 1
      ;;
  esac
  
  if [[ -n "$info" ]]; then
    echo "$info" | tee "$cache_file"
    return 0
  else
    # Cache empty result to avoid repeated failures
    touch "$cache_file"
    return 1
  fi
}

# Optimized batch installation
batch_install_packages() {
  local packages=("$@")
  local batch_size=10
  local current_batch=()
  local batch_count=0
  
  # Mark installation as active for resource monitoring
  touch "${CACHE_DIR}/installation_active"
  
  log_info "Starting batch installation of ${#packages[@]} packages"
  
  # Pre-fetch package information in parallel
  prefetch_package_info "${packages[@]}" &
  local prefetch_pid=$!
  
  # Process packages in batches
  for package in "${packages[@]}"; do
    current_batch+=("$package")
    
    if [[ ${#current_batch[@]} -eq $batch_size ]]; then
      ((batch_count++))
      log_info "Installing batch $batch_count (${#current_batch[@]} packages)"
      
      # Wait for prefetch to complete for this batch
      wait $prefetch_pid 2>/dev/null || true
      
      # Install current batch
      if install_package_batch "${current_batch[@]}"; then
        log_success "Batch $batch_count completed successfully"
      else
        log_warning "Some packages in batch $batch_count failed"
      fi
      
      # Reset batch
      current_batch=()
      
      # Brief pause to prevent system overload
      sleep 1
    fi
  done
  
  # Install remaining packages
  if [[ ${#current_batch[@]} -gt 0 ]]; then
    ((batch_count++))
    log_info "Installing final batch $batch_count (${#current_batch[@]} packages)"
    install_package_batch "${current_batch[@]}"
  fi
  
  # Stop resource monitoring
  stop_resource_monitoring
  
  log_info "Batch installation completed"
}

prefetch_package_info() {
  local packages=("$@")
  
  # Prefetch package information in parallel
  local pids=()
  local max_parallel=4
  local current_parallel=0
  
  for package in "${packages[@]}"; do
    # Limit parallel prefetch operations
    if [[ $current_parallel -ge $max_parallel ]]; then
      wait "${pids[0]}" 2>/dev/null || true
      pids=("${pids[@]:1}")  # Remove first PID
      ((current_parallel--))
    fi
    
    # Start prefetch in background
    {
      get_cached_package_info "$package" "basic" >/dev/null 2>&1
      get_cached_package_info "$package" "dependencies" >/dev/null 2>&1
    } &
    
    pids+=($!)
    ((current_parallel++))
  done
  
  # Wait for all prefetch operations to complete
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done
}

install_package_batch() {
  local packages=("$@")
  local success_count=0
  local failure_count=0
  
  # Update package index once per batch
  update_package_index
  
  # Attempt to install all packages in one command first
  log_info "Attempting batch installation: ${packages[*]}"
  
  if timeout 600 sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
     -o DPkg::Lock::Timeout=60 \
     "${packages[@]}" >/dev/null 2>&1; then
    log_success "Batch installation successful for all packages"
    return 0
  fi
  
  # If batch installation fails, try individual packages
  log_info "Batch installation failed, trying individual packages..."
  
  for package in "${packages[@]}"; do
    if install_single_package_optimized "$package"; then
      ((success_count++))
      log_success "Installed: $package"
    else
      ((failure_count++))
      log_warning "Failed: $package"
    fi
  done
  
  log_info "Batch results: $success_count successful, $failure_count failed"
  
  # Return success if at least half succeeded
  [[ $success_count -gt $failure_count ]]
}

install_single_package_optimized() {
  local package="$1"
  local max_attempts=2
  local attempt=1
  
  # Check if already installed (cached check)
  if is_package_installed_cached "$package"; then
    log_info "$package is already installed"
    return 0
  fi
  
  while [[ $attempt -le $max_attempts ]]; do
    # Use shorter timeout for individual packages
    if timeout 180 sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
       -o DPkg::Lock::Timeout=30 \
       -o APT::Get::AllowUnauthenticated=false \
       "$package" >/dev/null 2>&1; then
      
      # Cache the installation status
      cache_package_status "$package" "installed"
      return 0
    else
      local exit_code=$?
      
      if [[ $attempt -lt $max_attempts ]]; then
        log_debug "Retry $attempt for $package (exit code: $exit_code)"
        sleep 2
      fi
      
      ((attempt++))
    fi
  done
  
  # Cache the failure
  cache_package_status "$package" "failed"
  return 1
}

is_package_installed_cached() {
  local package="$1"
  local cache_file="${CACHE_DIR}/status_${package//\//_}"
  local cache_ttl=300  # 5 minutes for status cache
  
  # Check cache
  if [[ -f "$cache_file" ]] && [[ $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $cache_ttl ]]; then
    local status
    status=$(cat "$cache_file")
    [[ "$status" == "installed" ]]
    return $?
  fi
  
  # Check actual status and cache result
  if is_package_installed "$package"; then
    echo "installed" > "$cache_file"
    return 0
  else
    echo "not_installed" > "$cache_file"
    return 1
  fi
}

cache_package_status() {
  local package="$1"
  local status="$2"
  local cache_file="${CACHE_DIR}/status_${package//\//_}"
  
  echo "$status" > "$cache_file"
}

# Optimized GitHub installation with parallel downloads
install_from_github_optimized() {
  local repo="$1"
  local pattern="$2"
  local install_cmd="$3"
  local binary_name="${4:-$(echo "$repo" | cut -d/ -f2)}"
  
  init_logging
  
  # Check if already installed (cached)
  if command_exists "$binary_name"; then
    local current_version
    current_version=$("$binary_name" --version 2>&1 | head -n1 | awk '{print $NF}' || echo "unknown")
    log_info "$binary_name is already installed (version: $current_version)"
    finish_logging
    return 0
  fi
  
  log_info "Installing $binary_name from GitHub ($repo)..."
  
  # Use cached GitHub API response if available
  local api_cache="${CACHE_DIR}/github_${repo//\//_}_releases"
  local download_url
  
  if [[ -f "$api_cache" ]] && [[ $(($(date +%s) - $(stat -c %Y "$api_cache"))) -lt 1800 ]]; then
    # Use cached API response (30 minutes TTL)
    download_url=$(grep "browser_download_url" "$api_cache" | grep -E "$pattern" | head -1 | cut -d '"' -f 4)
  else
    # Fetch fresh API response
    log_info "Fetching release information from GitHub..."
    if curl -s --connect-timeout 10 --max-time 30 \
       "https://api.github.com/repos/$repo/releases/latest" > "$api_cache.tmp"; then
      mv "$api_cache.tmp" "$api_cache"
      download_url=$(grep "browser_download_url" "$api_cache" | grep -E "$pattern" | head -1 | cut -d '"' -f 4)
    else
      log_error "Failed to fetch GitHub release information"
      rm -f "$api_cache.tmp"
      finish_logging
      return 1
    fi
  fi
  
  if [[ -z "$download_url" ]]; then
    log_error "No download URL found for $binary_name with pattern $pattern"
    finish_logging
    return 1
  fi
  
  # Optimized download with resume capability
  local temp_file="${CACHE_DIR}/${binary_name}_download_$(basename "$download_url")"
  log_info "Downloading from $download_url"
  
  # Use wget with resume capability and progress bar
  if wget --continue --progress=bar:force:noscroll --timeout=30 --tries=3 \
     -O "$temp_file" "$download_url" 2>&1 | \
     stdbuf -oL tr '\r' '\n' | grep -o '[0-9]*%' | tail -1; then
    log_success "Download complete"
    
    # Install using the provided command
    local cmd="${install_cmd//\$1/$temp_file}"
    log_info "Installing with command: $cmd"
    
    if eval "$cmd"; then
      log_success "$binary_name installed successfully"
      rm -f "$temp_file"
      finish_logging
      return 0
    else
      log_error "Failed to install $binary_name"
      rm -f "$temp_file"
      finish_logging
      return 1
    fi
  else
    log_error "Failed to download $binary_name"
    rm -f "$temp_file"
    finish_logging
    return 1
  fi
}

# Cleanup cache function
cleanup_cache() {
  local max_age_days="${1:-7}"
  
  if [[ ! -d "$CACHE_DIR" ]]; then
    return 0
  fi
  
  log_info "Cleaning up cache files older than $max_age_days days..."
  
  # Remove old cache files
  find "$CACHE_DIR" -type f -mtime +$max_age_days -delete 2>/dev/null || true
  
  # Remove empty directories
  find "$CACHE_DIR" -type d -empty -delete 2>/dev/null || true
  
  log_info "Cache cleanup completed"
}

# Enhanced update function with optimizations
update_package_index_optimized() {
  local force_update="${1:-false}"
  local update_cache="${CACHE_DIR}/last_apt_update"
  local update_interval=3600  # 1 hour
  
  # Check if recent update was performed
  if [[ "$force_update" != "true" ]] && [[ -f "$update_cache" ]]; then
    local last_update
    last_update=$(
```
```bash:util-install.sh
update_package_index_optimized() {
  local force_update="${1:-false}"
  local update_cache="${CACHE_DIR}/last_apt_update"
  local update_interval=3600  # 1 hour
  
  # Check if recent update was performed
  if [[ "$force_update" != "true" ]] && [[ -f "$update_cache" ]]; then
    local last_update
    last_update=$(stat -c %Y "$update_cache" 2>/dev/null || echo "0")
    local current_time
    current_time=$(date +%s)
    
    if [[ $((current_time - last_update)) -lt $update_interval ]]; then
      log_info "Package index recently updated, skipping..."
      return 0
    fi
  fi
  
  log_info "Updating package index..."
  
  # Perform update with timeout and retry
  local max_attempts=3
  local attempt=1
  
  while [[ $attempt -le $max_attempts ]]; do
    if timeout 120 sudo apt-get update >/dev/null 2>&1; then
      touch "$update_cache"
      log_success "Package index updated successfully"
      return 0
    else
      log_warning "Package index update attempt $attempt failed"
      
      if [[ $attempt -lt $max_attempts ]]; then
        sleep $((attempt * 5))
      fi
      
      ((attempt++))
    fi
  done
  
  log_error "Failed to update package index after $max_attempts attempts"
  return 1
}

# Resource usage monitoring functions
get_memory_usage_percentage() {
  local mem_info
  mem_info=$(cat /proc/meminfo)
  
  local mem_total mem_available
  mem_total=$(echo "$mem_info" | grep "MemTotal:" | awk '{print $2}')
  mem_available=$(echo "$mem_info" | grep "MemAvailable:" | awk '{print $2}')
  
  if [[ -n "$mem_total" ]] && [[ -n "$mem_available" ]] && [[ $mem_total -gt 0 ]]; then
    echo $(( (mem_total - mem_available) * 100 / mem_total ))
  else
    echo "0"
  fi
}

get_disk_usage_percentage() {
  local disk_usage
  disk_usage=$(df / | tail -1 | awk '{print $5}' | tr -d '%')
  echo "${disk_usage:-0}"
}

# Enhanced installation wrapper with all optimizations
optimized_install() {
  local component="$1"
  shift
  local packages=("$@")
  
  # Initialize optimizations
  init_performance_optimizations
  
  # Initialize state management
  if ! init_installation_state; then
    return 1
  fi
  
  # Record installation start
  record_installation_start "$component" "${packages[@]}"
  
  # Perform optimized batch installation
  if batch_install_packages "${packages[@]}"; then
    record_installation_success "$component"
    log_success "Successfully installed $component"
    return 0
  else
    record_installation_failure "$component" "Batch installation failed"
    log_error "Failed to install $component"
    return 1
  fi
}
```

**Benefits**: Significantly reduces installation time through batching and caching, minimizes system resource usage, provides intelligent retry mechanisms, and enables resume capability for large installations.

## **5. Enhanced Error Handling and Diagnostic Capabilities**

**Issue**: The current error handling is basic and doesn't provide sufficient diagnostic information for troubleshooting complex installation failures.

**Recommendation**:
```bash:util-install.sh
# Enhanced error handling and diagnostics
readonly DIAGNOSTIC_DIR="${HOME}/.ubuntu-dev-setup/diagnostics"
readonly ERROR_LOG="${DIAGNOSTIC_DIR}/errors.log"
readonly DIAGNOSTIC_LOG="${DIAGNOSTIC_DIR}/diagnostics.log"

# Error classification and handling
declare -A ERROR_CATEGORIES=(
  ["network"]="Network connectivity or download issues"
  ["permissions"]="Permission or authentication issues"
  ["dependencies"]="Package dependency conflicts"
  ["disk_space"]="Insufficient disk space"
  ["system"]="System configuration issues"
  ["package"]="Package not found or corrupted"
  ["lock"]="Package manager lock issues"
  ["unknown"]="Unclassified error"
)

# Initialize diagnostic system
init_diagnostic_system() {
  mkdir -p "$DIAGNOSTIC_DIR"
  
  # Set up error trap with enhanced diagnostics
  trap 'handle_error $? $LINENO $BASH_COMMAND' ERR
  
  # Initialize diagnostic log
  echo "=== Diagnostic Session Started: $(date -Iseconds) ===" >> "$DIAGNOSTIC_LOG"
  
  # Collect initial system state
  collect_system_baseline
}

handle_error() {
  local exit_code=$1
  local line_number=$2
  local command="$3"
  local function_name="${FUNCNAME[2]:-main}"
  
  # Classify the error
  local error_category
  error_category=$(classify_error "$exit_code" "$command")
  
  # Generate detailed error report
  generate_error_report "$exit_code" "$line_number" "$command" "$function_name" "$error_category"
  
  # Collect diagnostic information
  collect_error_diagnostics "$error_category"
  
  # Suggest remediation
  suggest_remediation "$error_category" "$command" "$exit_code"
  
  # Log structured error information
  log_structured_error "$exit_code" "$line_number" "$command" "$function_name" "$error_category"
}

classify_error() {
  local exit_code=$1
  local command="$2"
  
  # Network-related errors
  if [[ "$command" =~ (wget|curl|apt-get\ update) ]] && [[ $exit_code -eq 4 || $exit_code -eq 6 || $exit_code -eq 7 ]]; then
    echo "network"
    return
  fi
  
  # Permission errors
  if [[ $exit_code -eq 126 || $exit_code -eq 13 ]]; then
    echo "permissions"
    return
  fi
  
  # Package manager lock errors
  if [[ "$command" =~ apt ]] && [[ $exit_code -eq 100 ]]; then
    echo "lock"
    return
  fi
  
  # Disk space errors
  if [[ $exit_code -eq 28 ]] || [[ "$command" =~ apt ]] && grep -q "No space left" /var/log/apt/term.log 2>/dev/null; then
    echo "disk_space"
    return
  fi
  
  # Dependency errors
  if [[ "$command" =~ apt ]] && [[ $exit_code -eq 1 ]]; then
    echo "dependencies"
    return
  fi
  
  # Package not found
  if [[ "$command" =~ apt ]] && [[ $exit_code -eq 100 ]]; then
    echo "package"
    return
  fi
  
  # System configuration issues
  if [[ $exit_code -eq 1 ]] && [[ "$command" =~ (systemctl|service) ]]; then
    echo "system"
    return
  fi
  
  # Default to unknown
  echo "unknown"
}

generate_error_report() {
  local exit_code=$1
  local line_number=$2
  local command="$3"
  local function_name="$4"
  local error_category="$5"
  
  local timestamp
  timestamp=$(date -Iseconds)
  
  # Create detailed error report
  cat >> "$ERROR_LOG" << EOF

=== ERROR REPORT ===
Timestamp: $timestamp
Exit Code: $exit_code
Line Number: $line_number
Function: $function_name
Command: $command
Category: $error_category
Description: ${ERROR_CATEGORIES[$error_category]}

=== SYSTEM CONTEXT ===
$(get_system_context)

=== RECENT LOG ENTRIES ===
$(get_recent_log_entries)

=== END ERROR REPORT ===

EOF
}

collect_error_diagnostics() {
  local error_category="$1"
  
  case "$error_category" in
    "network")
      collect_network_diagnostics
      ;;
    "permissions")
      collect_permission_diagnostics
      ;;
    "dependencies")
      collect_dependency_diagnostics
      ;;
    "disk_space")
      collect_disk_diagnostics
      ;;
    "system")
      collect_system_diagnostics
      ;;
    "package")
      collect_package_diagnostics
      ;;
    "lock")
      collect_lock_diagnostics
      ;;
    *)
      collect_general_diagnostics
      ;;
  esac
}

collect_network_diagnostics() {
  {
    echo "=== NETWORK DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- Connectivity Tests ---"
    ping -c 3 8.8.8.8 2>&1 || echo "Ping to 8.8.8.8 failed"
    ping -c 3 google.com 2>&1 || echo "Ping to google.com failed"
    
    echo "--- DNS Resolution ---"
    nslookup archive.ubuntu.com 2>&1 || echo "DNS resolution failed"
    
    echo "--- Network Interfaces ---"
    ip addr show 2>&1 || ifconfig 2>&1 || echo "Cannot get network interface info"
    
    echo "--- Routing Table ---"
    ip route show 2>&1 || route -n 2>&1 || echo "Cannot get routing info"
    
    echo "--- APT Sources ---"
    cat /etc/apt/sources.list 2>&1 || echo "Cannot read sources.list"
    ls -la /etc/apt/sources.list.d/ 2>&1 || echo "Cannot list sources.list.d"
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_permission_diagnostics() {
  {
    echo "=== PERMISSION DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- User Information ---"
    id
    groups
    
    echo "--- Sudo Configuration ---"
    sudo -l 2>&1 || echo "Cannot check sudo permissions"
    
    echo "--- File Permissions ---"
    ls -la /var/lib/dpkg/ 2>&1 || echo "Cannot check dpkg permissions"
    ls -la /var/cache/apt/ 2>&1 || echo "Cannot check apt cache permissions"
    
    echo "--- Process Information ---"
    ps aux | grep -E "(apt|dpkg)" || echo "No apt/dpkg processes found"
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_dependency_diagnostics() {
  {
    echo "=== DEPENDENCY DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- Package Status ---"
    dpkg --audit 2>&1 || echo "Cannot run dpkg audit"
    
    echo "--- Broken Packages ---"
    apt-get check 2>&1 || echo "Cannot check package integrity"
    
    echo "--- Held Packages ---"
    apt-mark showhold 2>&1 || echo "Cannot show held packages"
    
    echo "--- APT Cache Stats ---"
    apt-cache stats 2>&1 || echo "Cannot get apt cache stats"
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_disk_diagnostics() {
  {
    echo "=== DISK SPACE DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- Disk Usage ---"
    df -h
    
    echo "--- Inode Usage ---"
    df -i
    
    echo "--- Large Files in /tmp ---"
    find /tmp -type f -size +100M -ls 2>/dev/null || echo "Cannot find large temp files"
    
    echo "--- APT Cache Size ---"
    du -sh /var/cache/apt/ 2>/dev/null || echo "Cannot check apt cache size"
    
    echo "--- Package Cache ---"
    apt-cache stats | grep "Total space accounted for" || echo "Cannot get cache stats"
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_system_diagnostics() {
  {
    echo "=== SYSTEM DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- System Load ---"
    uptime
    
    echo "--- Memory Usage ---"
    free -h
    
    echo "--- Running Services ---"
    systemctl list-units --failed 2>&1 || echo "Cannot list failed services"
    
    echo "--- System Logs ---"
    journalctl --since "5 minutes ago" --no-pager -n 20 2>&1 || echo "Cannot access system logs"
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_lock_diagnostics() {
  {
    echo "=== LOCK DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- Lock Files ---"
    ls -la /var/lib/dpkg/lock* 2>&1 || echo "Cannot check dpkg locks"
    ls -la /var/cache/apt/archives/lock 2>&1 || echo "Cannot check apt locks"
    
    echo "--- Processes Using Locks ---"
    lsof /var/lib/dpkg/lock* 2>&1 || echo "Cannot check lock usage"
    lsof /var/cache/apt/archives/lock 2>&1 || echo "Cannot check apt lock usage"
    
    echo "--- APT Processes ---"
    ps aux | grep -E "(apt|dpkg|unattended-upgrade)" || echo "No package management processes found"
    
  } >> "$DIAGNOSTIC_LOG"
}

suggest_remediation() {
  local error_category="$1"
  local command="$2"
  local exit_code="$3"
  
  log_info "=== SUGGESTED REMEDIATION ==="
  
  case "$error_category" in
    "network")
      log_info "Network connectivity issues detected:"
      log_info "1. Check your internet connection"
      log_info "2. Try: sudo apt-get update"
      log_info "3. Check firewall settings"
      log_info "4. Verify DNS configuration"
      ;;
    "permissions")
      log_info "Permission issues detected:"
      log_info "1. Ensure you have sudo privileges"
      log_info "2. Try: sudo chown -R \$USER:\$USER ~/.ubuntu-dev-setup"
      log_info "3. Check if running as root (not recommended)"
      ;;
    "dependencies")
      log_info "Dependency issues detected:"
      log_info "1. Try: sudo apt-get install -f"
      log_info "2. Try: sudo dpkg --configure -a"
      log_info "3. Try: sudo apt-get autoremove"
      ;;
    "disk_space")
      log_info "Disk space issues detected:"
      log_info "1. Free up disk space"
      log_info "2. Try: sudo apt-get clean"
      log_info "3. Try: sudo apt-get autoremove"
      log_info "4. Check: df -h"
      ;;
    "lock")
      log_info "Package manager lock detected:"
      log_info "1. Wait for other package operations to complete"
      log_info "2. Try: sudo killall apt apt-get"
      log_info "3. Try: sudo rm /var/lib/dpkg/lock*"
      log_info "4. Try: sudo dpkg --configure -a"
      ;;
    "package")
```
```bash:util-install.sh
    "package")
      log_info "Package issues detected:"
      log_info "1. Try: sudo apt-get update"
      log_info "2. Check if package name is correct"
      log_info "3. Try: apt-cache search <package-name>"
      log_info "4. Check if package is available in your Ubuntu version"
      ;;
    "system")
      log_info "System configuration issues detected:"
      log_info "1. Check system logs: journalctl -xe"
      log_info "2. Verify systemd services: systemctl status"
      log_info "3. Check for failed services: systemctl --failed"
      ;;
    *)
      log_info "General troubleshooting steps:"
      log_info "1. Check the error log: $ERROR_LOG"
      log_info "2. Review diagnostic information: $DIAGNOSTIC_LOG"
      log_info "3. Try running the command manually with verbose output"
      log_info "4. Check Ubuntu version compatibility"
      ;;
  esac
  
  # Provide specific command suggestions based on the failed command
  if [[ "$command" =~ apt-get ]]; then
    log_info ""
    log_info "APT-specific suggestions:"
    log_info "- Try with --fix-missing: sudo apt-get install --fix-missing <package>"
    log_info "- Force reconfigure: sudo dpkg-reconfigure <package>"
    log_info "- Check package policy: apt-cache policy <package>"
  fi
  
  log_info ""
  log_info "For detailed diagnostics, check: $DIAGNOSTIC_LOG"
  log_info "For error history, check: $ERROR_LOG"
}

log_structured_error() {
  local exit_code=$1
  local line_number=$2
  local command="$3"
  local function_name="$4"
  local error_category="$5"
  
  # Create structured error entry for programmatic analysis
  local timestamp
  timestamp=$(date -Iseconds)
  
  # JSON-like structured log entry
  cat >> "${DIAGNOSTIC_DIR}/structured_errors.log" << EOF
{
  "timestamp": "$timestamp",
  "exit_code": $exit_code,
  "line_number": $line_number,
  "command": "$command",
  "function": "$function_name",
  "category": "$error_category",
  "description": "${ERROR_CATEGORIES[$error_category]}",
  "system_info": {
    "ubuntu_version": "$(lsb_release -rs 2>/dev/null || echo 'unknown')",
    "kernel_version": "$(uname -r)",
    "architecture": "$(uname -m)",
    "environment": "$(detect_environment 2>/dev/null || echo 'unknown')"
  }
}
EOF
}

get_system_context() {
  cat << EOF
Ubuntu Version: $(lsb_release -ds 2>/dev/null || echo "Unknown")
Kernel: $(uname -r)
Architecture: $(uname -m)
Environment: $(detect_environment 2>/dev/null || echo "Unknown")
Uptime: $(uptime | cut -d',' -f1)
Load Average: $(uptime | awk -F'load average:' '{print $2}')
Memory: $(free -h | grep Mem | awk '{print $3"/"$2}')
Disk Usage: $(df -h / | tail -1 | awk '{print $5}')
EOF
}

get_recent_log_entries() {
  # Get recent entries from various logs
  {
    echo "--- APT Log (last 10 lines) ---"
    tail -10 /var/log/apt/term.log 2>/dev/null || echo "APT log not accessible"
    
    echo "--- System Log (last 5 entries) ---"
    journalctl --since "5 minutes ago" --no-pager -n 5 2>/dev/null || echo "System log not accessible"
    
    echo "--- Installation Log (last 5 lines) ---"
    tail -5 "$INSTALLATION_LOG" 2>/dev/null || echo "Installation log not found"
    
  } | head -50  # Limit output size
}

collect_system_baseline() {
  {
    echo "=== SYSTEM BASELINE ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- System Information ---"
    get_system_context
    
    echo "--- Package Manager Status ---"
    apt-cache stats 2>&1 || echo "Cannot get apt stats"
    
    echo "--- Initial Package State ---"
    dpkg -l | wc -l | awk '{print "Installed packages: " $1}'
    
    echo "--- Environment Variables ---"
    env | grep -E "(PATH|DEBIAN_FRONTEND|APT_|DPKG_)" | sort
    
  } >> "$DIAGNOSTIC_LOG"
}

collect_general_diagnostics() {
  {
    echo "=== GENERAL DIAGNOSTICS ==="
    echo "Timestamp: $(date -Iseconds)"
    
    echo "--- Process List ---"
    ps aux | head -20
    
    echo "--- Environment ---"
    env | sort
    
    echo "--- Mount Points ---"
    mount | grep -E "(ext|xfs|btrfs)"
    
  } >> "$DIAGNOSTIC_LOG"
}

# Enhanced installation wrapper with comprehensive error handling
safe_install_with_diagnostics() {
  local component="$1"
  shift
  local packages=("$@")
  
  # Initialize diagnostic system
  init_diagnostic_system
  
  # Initialize state management
  if ! init_installation_state; then
    return 1
  fi
  
  # Record installation start
  record_installation_start "$component" "${packages[@]}"
  
  # Perform installation with enhanced error handling
  local installation_result=0
  
  {
    # Run installation in a subshell to capture all errors
    if optimized_install "$component" "${packages[@]}"; then
      record_installation_success "$component"
      log_success "Successfully installed $component"
    else
      installation_result=1
      record_installation_failure "$component" "Installation failed with diagnostics available"
      log_error "Failed to install $component - diagnostic information collected"
    fi
  } || {
    installation_result=1
    log_error "Critical error during installation of $component"
  }
  
  # Generate installation summary
  generate_installation_summary "$component" "$installation_result"
  
  return $installation_result
}

generate_installation_summary() {
  local component="$1"
  local result="$2"
  
  local summary_file="${DIAGNOSTIC_DIR}/installation_summary_${component}.txt"
  
  {
    echo "=== INSTALLATION SUMMARY: $component ==="
    echo "Timestamp: $(date -Iseconds)"
    echo "Result: $([ $result -eq 0 ] && echo "SUCCESS" || echo "FAILED")"
    echo ""
    
    if [[ $result -ne 0 ]]; then
      echo "=== ERROR INFORMATION ==="
      echo "Check detailed logs at:"
      echo "- Error log: $ERROR_LOG"
      echo "- Diagnostic log: $DIAGNOSTIC_LOG"
      echo "- Structured errors: ${DIAGNOSTIC_DIR}/structured_errors.log"
      echo ""
      
      echo "=== QUICK DIAGNOSTICS ==="
      echo "Recent errors:"
      tail -5 "$ERROR_LOG" 2>/dev/null || echo "No recent errors logged"
      echo ""
      
      echo "System status:"
      get_system_context
    else
      echo "=== SUCCESS INFORMATION ==="
      echo "Installation completed successfully"
      echo "All packages installed without errors"
    fi
    
    echo ""
    echo "=== NEXT STEPS ==="
    if [[ $result -ne 0 ]]; then
      echo "1. Review the error logs above"
      echo "2. Follow the suggested remediation steps"
      echo "3. Try running the installation again"
      echo "4. If issues persist, check Ubuntu compatibility"
    else
      echo "1. Verify installation: validate-installation.sh"
      echo "2. Continue with next components"
    fi
    
  } | tee "$summary_file"
  
  log_info "Installation summary saved to: $summary_file"
}

# Diagnostic report generation
generate_diagnostic_report() {
  local output_file="${1:-${DIAGNOSTIC_DIR}/full_diagnostic_report.txt}"
  
  {
    echo "=== COMPREHENSIVE DIAGNOSTIC REPORT ==="
    echo "Generated: $(date -Iseconds)"
    echo "Report Location: $output_file"
    echo ""
    
    echo "=== SYSTEM OVERVIEW ==="
    get_system_context
    echo ""
    
    echo "=== ERROR SUMMARY ==="
    if [[ -f "$ERROR_LOG" ]]; then
      echo "Total errors logged: $(grep -c "=== ERROR REPORT ===" "$ERROR_LOG" 2>/dev/null || echo "0")"
      echo ""
      echo "Recent errors:"
      tail -20 "$ERROR_LOG" 2>/dev/null || echo "No errors found"
    else
      echo "No error log found"
    fi
    echo ""
    
    echo "=== INSTALLATION HISTORY ==="
    get_installation_history "text"
    echo ""
    
    echo "=== SYSTEM DIAGNOSTICS ==="
    if [[ -f "$DIAGNOSTIC_LOG" ]]; then
      tail -50 "$DIAGNOSTIC_LOG"
    else
      echo "No diagnostic log found"
    fi
    
  } > "$output_file"
  
  log_info "Comprehensive diagnostic report generated: $output_file"
  echo "$output_file"
}

# Cleanup diagnostic files
cleanup_diagnostics() {
  local keep_days="${1:-30}"
  
  if [[ ! -d "$DIAGNOSTIC_DIR" ]]; then
    return 0
  fi
  
  log_info "Cleaning up diagnostic files older than $keep_days days..."
  
  # Remove old diagnostic files
  find "$DIAGNOSTIC_DIR" -type f -mtime +$keep_days -delete 2>/dev/null || true
  
  # Compress large log files
  find "$DIAGNOSTIC_DIR" -name "*.log" -size +10M -exec gzip {} \; 2>/dev/null || true
  
  log_info "Diagnostic cleanup completed"
}
```

**Benefits**: Provides comprehensive error classification and diagnosis, enables faster troubleshooting through structured error reporting, offers specific remediation suggestions, and maintains detailed diagnostic history for pattern analysis.

---

## **Summary**

The `util-install.sh` script demonstrates solid foundational design principles with good modularization and error handling. However, there are **significant opportunities to enhance code quality** in several key areas:

**Major Enhancement Areas:**
1. **Security**: Input validation and sanitization need strengthening to prevent injection attacks
2. **Reliability**: Advanced dependency resolution and rollback capabilities would prevent broken installations
3. **Performance**: Caching, batching, and resource optimization could dramatically improve installation speed
4. **Maintainability**: Persistent state management and recovery mechanisms would improve robustness
5. **Diagnostics**: Enhanced error classification and diagnostic capabilities would significantly improve troubleshooting

**Current Strengths:**
- Good separation of concerns with utility functions
- Basic error handling and logging infrastructure
- Environment detection capabilities
- Modular design allowing for selective improvements

**Overall Assessment:**
While the script follows sound basic design principles, implementing these enhancements would transform it from a functional utility into a production-grade, enterprise-ready installation system. The suggested improvements address critical gaps in security, performance, and reliability that are essential for robust system automation.